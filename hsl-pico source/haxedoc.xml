<haxe>
	<enum path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>
	The standard Void type. Only [null] values can be of the type [Void].
</haxe_doc></enum>
	<class path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	The standard Float type, this is a double-precision IEEE 64bit float.
</haxe_doc></class>
	<class path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>
	The standard Int type. Its precision depends on the platform.
</haxe_doc>
	</class>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>
	[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.
</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>
	The standard Boolean type is represented as an enum with two choices.
</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.
</haxe_doc></class>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>
	An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.
</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>
	An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.
</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>
	ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.
</haxe_doc></class>
	<class path="hsl.haxe.GenericSignaler" params="ListenerSignature:SignalType:SignalerType" file="../hsl-pico source/hsl/haxe/GenericSignaler.hx" interface="1">
		<isListenedTo public="1" get="getIsListenedTo" set="null">
			<e path="Bool"/>
			<haxe_doc><![CDATA[
	 * Indicates whether the signaler is listened to by at least one listener.
	 * 
	 * This property can be used for speed optimizations. If a signaler is not listened to, its subject does not have to
	 * calculate a value if that value will only be sent in a signal.
	 * 
	 * In this example the "Ball" class only calculates the distance if a listener is added to the signaler:
	 * <pre>
	 * package;
	 * import hsl.haxe.direct.DirectSignaler;
	 * import hsl.haxe.Signaler;
	 * class Ball {
	 * 	public var distanceUpdatedSignaler(default, null):DirectSignaler&lt;Float&gt;;
	 * 	public function new():Void {
	 * 		distanceUpdatedSignaler = new DirectSignaler(this);
	 * 	}
	 * 	public function move(x:Float, y:Float):Void {
	 * 		if (distanceUpdatedSignaler.isListenedTo) {
	 * 			var distance:Float = Math.sqrt(x * x + y * y);
	 * 			distanceUpdatedSignaler.dispatch(distance);
	 * 		}
	 * 	}
	 * }
	 * </pre>
	 ]]></haxe_doc>
		</isListenedTo>
		<subject public="1" set="null">
			<t path="hsl.haxe.Subject"/>
			<haxe_doc>
	 * The subject this signalers belongs to.
	 </haxe_doc>
		</subject>
		<addBubblingTarget public="1" set="method">
			<f a="value">
				<c path="hsl.haxe.GenericSignaler.SignalerType"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	 * Adds a bubbling target to the signaler. The signaler will bubble to this bubbling target in a bubbling process.
	 * 
	 * <ul><li>
	 * If you are familiar with events in ActionScript 3.0, or as3-signals by Robert Penner: those systems do not have an
	 * equivalent to this method, as they don't allow you to manually define where events/signals bubble to.
	 * </li></ul>
	 ]]></haxe_doc>
		</addBubblingTarget>
		<bind public="1" set="method">
			<f a="listener">
				<c path="hsl.haxe.GenericSignaler.ListenerSignature"/>
				<c path="hsl.haxe.Bond"/>
			</f>
			<haxe_doc><![CDATA[
	 * Binds this signaler to a listener function that accepts an argument of the datatype of this signaler, and returns nothing.
	 * Returns the bond between the signaler. The bond can be removed by calling either the unbind method of the signaler, or the
	 * destroy method of the returned bond.
	 * 
	 * <ul><li>
	 * If you are familiar with jQuery: this method is similar to the "bind" method of that library.
	 * </li><li>
	 * If you are familiar with as3-signals by Robert Penner: this method is similar to the "add" method of that library.
	 * </li><li>
	 * If you are familiar with events in ActionScript 3.0: this method is similar to the "addEventListener" method of that
	 * system, though the bindAdvanced method of this library has more similarities to addEventListener.
	 * </li></ul>
	 ]]></haxe_doc>
		</bind>
		<bindAdvanced public="1" set="method">
			<f a="listener">
				<f a="">
					<c path="hsl.haxe.GenericSignaler.SignalType"/>
					<e path="Void"/>
				</f>
				<c path="hsl.haxe.Bond"/>
			</f>
			<haxe_doc><![CDATA[
	 * Binds this signaler to a listener function that accepts a signal, and returns nothing. Returns the bond between the
	 * signaler. The bond can be removed by calling either the unbindAdvanced method of the signaler, or the destroy method of
	 * the returned bond.
	 * 
	 * <ul><li>
	 * If you are familiar with jQuery: this method is similar to the "bind" method of that library.
	 * </li><li>
	 * If you are familiar with as3-signals by Robert Penner: this method is similar to the "add" method of that library, though
	 * the bind method of this library has more similarities to add.
	 * </li><li>
	 * If you are familiar with events in ActionScript 3.0: this method is similar to the "addEventListener" method of that
	 * system.
	 * </li></ul>
	 ]]></haxe_doc>
		</bindAdvanced>
		<bindVoid public="1" set="method">
			<f a="listener">
				<f a=""><e path="Void"/></f>
				<c path="hsl.haxe.Bond"/>
			</f>
			<haxe_doc><![CDATA[
	 * Binds this signaler to a listener function that accepts nothing, and returns nothing. Returns the bond between the
	 * signaler. The bond can be removed by calling either the unbindVoid method of the signaler, or the destroy method of the
	 * returned bond.
	 * 
	 * <ul><li>
	 * If you are familiar with jQuery: this method is similar to the "bind" method of that library.
	 * </li><li>
	 * If you are familiar with as3-signals by Robert Penner: this method is similar to the "add" method of that library, though
	 * the bind method of this library has more similarities to add.
	 * </li><li>
	 * If you are familiar with events in ActionScript 3.0: this method is similar to the "addEventListener" method of that
	 * system, though the bindAdvanced method of this library has more similarities to addEventListener.
	 * </li></ul>
	 ]]></haxe_doc>
		</bindVoid>
		<getIsListenedTo set="method"><f a=""><e path="Bool"/></f></getIsListenedTo>
		<removeBubblingTarget public="1" set="method">
			<f a="value">
				<c path="hsl.haxe.GenericSignaler.SignalerType"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removes a bubbling target from the signaler. The signaler will stop bubbling to this bubbling target. If the signaler
	 * does not have the passed value as a bubbling target, calling this method has no effect.
	 </haxe_doc>
		</removeBubblingTarget>
		<unbind public="1" set="method">
			<f a="listener">
				<c path="hsl.haxe.GenericSignaler.ListenerSignature"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removed the bond between this signaler and a listener. If such bond does not exist, calling this method has no effect.
	 </haxe_doc>
		</unbind>
		<unbindAdvanced public="1" set="method">
			<f a="listener">
				<f a="">
					<c path="hsl.haxe.GenericSignaler.SignalType"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removed the bond between this signaler and a listener. If such bond does not exist, calling this method has no effect.
	 </haxe_doc>
		</unbindAdvanced>
		<unbindVoid public="1" set="method">
			<f a="listener">
				<f a=""><e path="Void"/></f>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Removed the bond between this signaler and a listener. If such bond does not exist, calling this method has no effect.
	 </haxe_doc>
		</unbindVoid>
		<haxe_doc><![CDATA[
 * A signalers is a tool, used by a subject to notify its environment (listeners). Subjects create their signalers, usually in
 * their constructors. Listeners add themselves to signalers by calling one of the binding methods.
 * 
 * <ul><li>
 * If you are familiar with as3-signals by Robert Penner: signalers are similar to "signals" in that library.
 * </li><li>
 * If you are familiar with events in ActionScript 3.0: signalers have some similarities to "event dispatchers" in that system.
 * There is one major difference, though: an event dispatcher can dispatch events of different event types; but in this library
 * each type of signal has its own signaler.
 * </li></ul>
 ]]></haxe_doc>
	</class>
	<class path="hsl.haxe.BigSignaler" params="Datatype1:Datatype2" file="../hsl-pico source/hsl/haxe/BigSignaler.hx" interface="1">
		<implements path="hsl.haxe.GenericSignaler">
			<f a=":">
				<c path="hsl.haxe.BigSignaler.Datatype1"/>
				<c path="hsl.haxe.BigSignaler.Datatype2"/>
				<e path="Void"/>
			</f>
			<t path="hsl.haxe.BigSignal">
				<c path="hsl.haxe.BigSignaler.Datatype1"/>
				<c path="hsl.haxe.BigSignaler.Datatype2"/>
			</t>
			<c path="hsl.haxe.BigSignaler">
				<c path="hsl.haxe.BigSignaler.Datatype1"/>
				<c path="hsl.haxe.BigSignaler.Datatype2"/>
			</c>
		</implements>
		<dispatch public="1" set="method">
			<f a="?data1:?data2:?origin:?positionInformation">
				<c path="hsl.haxe.BigSignaler.Datatype1"/>
				<c path="hsl.haxe.BigSignaler.Datatype2"/>
				<t path="hsl.haxe.Subject"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Dispatches a signal, containing the passed data. All the listeners that are listening to this signaler will be notified.
	 * The signal will bubble to all of the bubbling targets that were added to this signaler. This method may only be called
	 * by the subject of the signaler.
	 </haxe_doc>
		</dispatch>
		<haxe_doc>
 * A signaler that dispatches signals with two data objects inside.
 </haxe_doc>
	</class>
	<class path="String" params="" file="/usr/lib/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of characters in the String.
	</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been uppercased.
	</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been lowercased.
	</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the character at the given position.
		Returns the empty String if outside of String bounds.
	</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Returns the character code at the given position.
		Returns [null] if outside of String bounds.
	</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="value:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.
	</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="value:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Similar to [indexOf] but returns the latest index.
	</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split the string using the specified delimiter.
	</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.
	</haxe_doc>
		</substr>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the String itself.
	</haxe_doc>
		</toString>
		<cca set="method"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></cca>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a copy from a given String.
	</haxe_doc>
		</new>
		<haxe_doc>
	The basic String class.
</haxe_doc>
	</class>
	<class path="Importer" params="" file="Importer.hx"/>
	<class path="Std" params="" file="/usr/lib/haxe/std/Std.hx">
		<is public="1" set="method" line="34" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value v is of the type t.
	</haxe_doc>
		</is>
		<string public="1" set="method" line="54" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Convert any value to a String
	</haxe_doc>
		</string>
		<int public="1" set="method" line="74" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Convert a Float to an Int, rounded down.
	</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="90" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.
	</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="131" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a String to a Float, parsing different possible reprensations.
	</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="153" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Return a random integer between 0 included and x excluded.
	</haxe_doc>
		</random>
		<haxe_doc>
	The Std class provides standard methods for manipulating basic types.
</haxe_doc>
	</class>
	<class path="hsl.haxe.Bond" params="" file="../hsl-pico source/hsl/haxe/Bond.hx">
		<halted public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Indicates whether the bond has been halted (true) or not (false). See the halt method for more information.
	 </haxe_doc>
		</halted>
		<destroy public="1" set="method" line="52">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Destroys the bond. The signaler that created this bond will no longer notify listeners through it. Bond cannot be
	 * "undestroyed". To temporary suspend the bond from notifying the associated listener, use the halt method.
	 </haxe_doc>
		</destroy>
		<halt public="1" get="inline" set="null" line="58">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Halts the bond. The bond will ignore any calls, and will not notify any listeners, until the resume method is called. If
	 * the bond was already halted, calling this method has no effect.
	 </haxe_doc>
		</halt>
		<resume public="1" get="inline" set="null" line="65">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Resumes the bond, after it has been halted by calling the halt method. If the bond was not halted, calling this method has
	 * no effect. See the halt method for more information.
	 </haxe_doc>
		</resume>
		<new public="1" set="method" line="42">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * Creates a new bond.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A bond represents the connection between a signaler and a listener. Bonds are created when listeners add themselves to a
 * signaler.
 * 
 * Bonds are used internally, and can be ignored in common cases. However, sometimes it is useful for listeners to store the
 * bond in a variable. Doing so allows you to halt and resume the bond, and destroy it easily.
 </haxe_doc>
	</class>
	<class path="Math" params="" file="/usr/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" set="method" static="1"><f a="value1:value2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" static="1"><f a="value1:value2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" static="1"><f a="value1:value2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" static="1"><f a="value1:value2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>
	This class defines mathematical functions and constants.
</haxe_doc>
	</class>
	<typedef path="hsl.haxe.Subject" params="" file="../hsl-pico source/hsl/haxe/Subject.hx">
		<a/>
		<haxe_doc><![CDATA[
 * A subject is an object that might have internal state changes, which could be of interest to their environment. It notifies
 * its environment of such state changes by dispatching signals, rather than directly calling one of the methods of the
 * listeners. Subjects dispatch signals through signalers. Listeners can add themselves to those signalers.
 * 
 * Use of this technique results in low coupling between the subjects and their listeners. See
 * <a href="http://en.wikipedia.org/wiki/Coupling_(computer_science)">Coupling</a> on Wikipedia for more information.
 * 
 * Any class can act as a subject. Subjects can have any number of signalers.
 * 
 * In this example, the "buddy" variable (an instance of the "Dog" class) is a subject. The main class is a listener.
 * <pre>
 * package;
 * import hsl.haxe.direct.DirectSignaler;
 * import hsl.haxe.Signaler;
 * class Main {
 * 	public static function traceSound(sound:String):Void {
 * 		trace(sound);
 * 	}
 * 	public static function main():Void {
 * 		var buddy:Dog = new Dog();
 * 		buddy.barkedSignaler.bind(traceSound);
 * 		buddy.bark();
 * 	}
 * }
 * class Dog {
 * 	public var barkedSignaler(default, null):Signaler&lt;String&gt;;
 * 	public function new():Void {
 * 		barkedSignaler = new DirectSignaler(this);
 * 	}
 * 	public inline function bark():Void {
 * 		barkedSignaler.dispatch("Woof");
 * 	}
 * }
 * </pre>
 ]]></haxe_doc>
	</typedef>
	<typedef path="hsl.haxe.HugeSignal" params="Datatype1:Datatype2:Datatype3" file="../hsl-pico source/hsl/haxe/HugeSignal.hx">
		<c path="hsl.haxe.GenericSignal">
			<c path="hsl.haxe.HugeSignal.Datatype1"/>
			<c path="hsl.haxe.HugeSignal.Datatype2"/>
			<c path="hsl.haxe.HugeSignal.Datatype3"/>
		</c>
		<haxe_doc>
 * A signal with three data object inside. See GenericSignal for more information on signals.
 * 
 * This typedef exists for consistency with the big signaler and the signaler.
 </haxe_doc>
	</typedef>
	<typedef path="hsl.haxe.Signal" params="Datatype" file="../hsl-pico source/hsl/haxe/Signal.hx">
		<c path="hsl.haxe.GenericSignal">
			<c path="hsl.haxe.Signal.Datatype"/>
			<e path="Void"/>
			<e path="Void"/>
		</c>
		<haxe_doc>
 * A signal with only one data object inside. See GenericSignaler for more information on signals.
 </haxe_doc>
	</typedef>
	<class path="hsl.haxe.GenericSignal" params="Datatype1:Datatype2:Datatype3" file="../hsl-pico source/hsl/haxe/GenericSignal.hx">
		<currentBond public="1" set="null">
			<c path="hsl.haxe.Bond"/>
			<haxe_doc>
	 * The bond that is currently processing the signal.
	 </haxe_doc>
		</currentBond>
		<currentTarget public="1" set="null">
			<t path="hsl.haxe.Subject"/>
			<haxe_doc><![CDATA[
	 * The subject that is currently dispatching this signal. This subject might be the origin for this signal, but could also be
	 * dispatching this signal in a bubbling process. For instance, if a user clicks on a button that is inside a menu, and
	 * signals bubble from that button to that menu, the currentTarget will be the button at some point and the menu at another.
	 * The origin will constantly be the button. In other words, the currentTarget is the subject the listener added itself to.
	 * 
	 * <ul><li>
	 * If you are familiar with events in ActionScript 3.0, jQuery, or any other system that was based on DOM level 3 events:
	 * this property is similar to the currentTarget property of the event objects in those systems.
	 * </li></ul>
	 * 
	 * In this example, the currentTarget property is used to determine which button was clicked. Note that this example is
	 * AVM2-specific, and requires the complete version of HSL (not just HSL-pico).
	 * <pre>
	 * package;
	 * import flash.display.Sprite;
	 * import flash.events.MouseEvent;
	 * import flash.Lib;
	 * import hsl.avm2.translating.AVM2Signaler;
	 * import hsl.haxe.direct.DirectSignaler;
	 * import hsl.haxe.Signal;
	 * import hsl.haxe.Signaler;
	 * class Main {
	 * 	public static function addButton(x:Float, color:Int):Void {
	 * 		var button:Button = new Button(color);
	 * 		button.x = x;
	 * 		button.clickedSignaler.bindAdvanced(handleButtonClicked);
	 * 		Lib.current.addChild(button);
	 * 	}
	 * 	public static function handleButtonClicked(signal:Signal&lt;Void&gt):Void {
	 * 		var button:Button = cast(signal.currentTarget, Button);
	 * 		trace("A button was clicked with this color: #" + StringTools.hex(button.color));
	 * 		removeButton(button);
	 * 	}
	 * 	private static function removeButton(button:Button):Void {
	 * 		button.clickedSignaler.unbindAdvanced(handleButtonClicked);
	 * 		Lib.current.removeChild(button);
	 * 	}
	 * 	public static function main():Void {
	 * 		addButton(0, 0x61C8E1);
	 * 		addButton(150, 0x61C8E1);
	 * 		addButton(300, 0xF68A1E);
	 * 		addButton(450, 0x61C8E1);
	 * 	}
	 * }
	 * class Button extends Sprite {
	 * 	public var clickedSignaler(default, null):Signaler&lt;Void&gt;;
	 * 	public var color:Int;
	 * 	public function new(color:Int):Void {
	 * 		super();
	 * 		clickedSignaler = new AVM2Signaler(this, this, MouseEvent.CLICK);
	 * 		this.color = color;
	 * 		buttonMode = true;
	 * 		draw();
	 * 	}
	 * 	private inline function draw():Void {
	 * 		graphics.beginFill(color);
	 * 		graphics.drawRoundRect(0, 0, 125, 77, 16);
	 * 		graphics.endFill();
	 * 	}
	 * }
	 * </pre>
	 * Note that this example is somewhat complex, and might be hard to understand if you are not familiar with the basics of
	 * this library.
	 ]]></haxe_doc>
		</currentTarget>
		<data1 public="1" set="null">
			<c path="hsl.haxe.GenericSignal.Datatype1"/>
			<haxe_doc>
	 * The first data element in this signal.
	 </haxe_doc>
		</data1>
		<data2 public="1" set="null">
			<c path="hsl.haxe.GenericSignal.Datatype2"/>
			<haxe_doc>
	 * The second data element in this signal.
	 </haxe_doc>
		</data2>
		<data3 public="1" set="null">
			<c path="hsl.haxe.GenericSignal.Datatype3"/>
			<haxe_doc>
	 * The third data element in this signal.
	 </haxe_doc>
		</data3>
		<immediatePropagationStopped public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Indicates whether stopImmediatePropagation method was called on this signal (true) or not (false).
	 </haxe_doc>
		</immediatePropagationStopped>
		<origin public="1" set="null">
			<t path="hsl.haxe.Subject"/>
			<haxe_doc><![CDATA[
	 * The subject that initially dispatched this signal. For instance, if a user clicks on a button that is inside a menu, and
	 * signals bubble from that button to that menu, the currentTarget will be the button at some point and the menu at another.
	 * The origin will constantly be the button. In other words, the origin is the subject that called the dispatch method.
	 * 
	 * <ul><li>
	 * If you are familiar with events in ActionScript 3.0, jQuery, or any other system that was based on DOM level 3 events:
	 * this property is similar to the target property of the event objects in those systems.
	 * </li></ul>
	 ]]></haxe_doc>
		</origin>
		<propagationStopped public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>
	 * Indicates whether stopPropagation method was called on this signal (true) or not (false).
	 </haxe_doc>
		</propagationStopped>
		<stopImmediatePropagation public="1" get="inline" set="null" line="213">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Stops all propagation of the signal. The subject currently dispatching this signal (as found in the target property of
	 * this the signal) stops doing so right away. Any other listeners that are listening are not notified.
	 * 
	 * <ul><li>
	 * If you are familiar with events in ActionScript 3.0, jQuery, or any other system that was based on DOM level 3 events:
	 * this method is similar to the stopImmediatePropagation method of the event objects in those systems.
	 * </li></ul>
	 * 
	 * In this example, the stopImmediatePropagation method is used to mute the sound that was produces by the "Muter" class:
	 * <pre>
	 * package;
	 * import hsl.haxe.direct.DirectSignaler;
	 * import hsl.haxe.Bond;
	 * import hsl.haxe.Signal;
	 * import hsl.haxe.Signaler;
	 * class Main {
	 * 	public static function traceCheer():Void {
	 * 		trace("Yay!");
	 * 	}
	 * 	public static function main():Void {
	 * 		var speaker:Speaker = new Speaker();
	 * 		var muter:Muter = new Muter(speaker);
	 * 		speaker.soundProducedSignaler.bindVoid(traceCheer);
	 * 		// This has no effect: the muter stops the signal propagation.
	 * 		speaker.produceSound();
	 * 		muter.disable();
	 * 		// This traces the cheer: the muter is disabled.
	 * 		speaker.produceSound();
	 * 		muter.enable();
	 * 		// This has no effect: the muter is re-enabled.
	 * 		speaker.produceSound();
	 * 	}
	 * }
	 * class Speaker {
	 * 	public var soundProducedSignaler(default, null):Signaler&lt;Void&gt;;
	 * 	public function new():Void {
	 * 		soundProducedSignaler = new DirectSignaler(this);
	 * 	}
	 * 	public inline function produceSound():Void {
	 * 		soundProducedSignaler.dispatch();
	 * 	}
	 * }
	 * class Muter {
	 * 	private var muteBond:Bond;
	 * 	public function new(speaker:Speaker):Void {
	 * 		muteBond = speaker.soundProducedSignaler.bindAdvanced(mute);
	 * 	}
	 * 	public inline function disable():Void {
	 * 		muteBond.halt();
	 * 	}
	 * 	public inline function enable():Void {
	 * 		muteBond.resume();
	 * 	}
	 * 	private function mute(signal:Signal&lt;Void&gt;):Void {
	 * 		signal.stopImmediatePropagation();
	 * 	}
	 * }
	 * </pre>
	 * Note that this example is somewhat complex, and might be hard to understand if you are not familiar with the basics of
	 * this library.
	 ]]></haxe_doc>
		</stopImmediatePropagation>
		<stopPropagation public="1" get="inline" set="null" line="226">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Stops the bubbling of the signal. The subject currently dispatching this signal (as found in the target property of this
	 * the signal) will not bubble it to its bubbling targets. Calling this method does not prevent other listeners of the same
	 * signaler from being called: see stopImmediatePropagation for that functionality.
	 * 
	 * <ul><li>
	 * If you are familiar with events in ActionScript 3.0, jQuery, or any other system that was based on DOM level 3 events:
	 * this method is similar to the stopPropagation method of the event objects in those systems.
	 * </li></ul>
	 ]]></haxe_doc>
		</stopPropagation>
		<new public="1" set="method" line="137">
			<f a="data1:data2:data3:currentBond:currentTarget:origin">
				<c path="hsl.haxe.GenericSignal.Datatype1"/>
				<c path="hsl.haxe.GenericSignal.Datatype2"/>
				<c path="hsl.haxe.GenericSignal.Datatype3"/>
				<c path="hsl.haxe.Bond"/>
				<t path="hsl.haxe.Subject"/>
				<t path="hsl.haxe.Subject"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Creates a new generic signal. Signals are usually created by signalers, so this constructor will probably not be called
	 * outside of the library itself.
	 </haxe_doc>
		</new>
		<haxe_doc>
 * A signal is dispatched by a subject, through a signaler. However, only listeners that were added using the bindAdvanced
 * method can access the actual Signal instances.
 </haxe_doc>
	</class>
	<typedef path="hsl.haxe.BigSignal" params="Datatype1:Datatype2" file="../hsl-pico source/hsl/haxe/BigSignal.hx">
		<c path="hsl.haxe.GenericSignal">
			<c path="hsl.haxe.BigSignal.Datatype1"/>
			<c path="hsl.haxe.BigSignal.Datatype2"/>
			<e path="Void"/>
		</c>
		<haxe_doc>
 * A signal with two data object inside. See GenericSignaler for more information on signals.
 </haxe_doc>
	</typedef>
	<class path="hsl.haxe.Signaler" params="Datatype" file="../hsl-pico source/hsl/haxe/Signaler.hx" interface="1">
		<implements path="hsl.haxe.GenericSignaler">
			<f a="">
				<c path="hsl.haxe.Signaler.Datatype"/>
				<e path="Void"/>
			</f>
			<t path="hsl.haxe.Signal"><c path="hsl.haxe.Signaler.Datatype"/></t>
			<c path="hsl.haxe.Signaler"><c path="hsl.haxe.Signaler.Datatype"/></c>
		</implements>
		<dispatch public="1" set="method">
			<f a="?data:?origin:?positionInformation">
				<c path="hsl.haxe.Signaler.Datatype"/>
				<t path="hsl.haxe.Subject"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Dispatches a signal, containing the passed data. All the listeners that are listening to this signaler will be notified.
	 * The signal will bubble to all of the bubbling targets that were added to this signaler. This method may only be called
	 * by the subject of the signaler.
	 </haxe_doc>
		</dispatch>
		<haxe_doc>
 * A signaler that dispatches signals with only one data object inside. See GenericSignaler for more information on signalers.
 </haxe_doc>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams><c path="Array"><d/></c></customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="hsl.haxe.HugeSignaler" params="Datatype1:Datatype2:Datatype3" file="../hsl-pico source/hsl/haxe/HugeSignaler.hx" interface="1">
		<implements path="hsl.haxe.GenericSignaler">
			<f a="::">
				<c path="hsl.haxe.HugeSignaler.Datatype1"/>
				<c path="hsl.haxe.HugeSignaler.Datatype2"/>
				<c path="hsl.haxe.HugeSignaler.Datatype3"/>
				<e path="Void"/>
			</f>
			<t path="hsl.haxe.HugeSignal">
				<c path="hsl.haxe.HugeSignaler.Datatype1"/>
				<c path="hsl.haxe.HugeSignaler.Datatype2"/>
				<c path="hsl.haxe.HugeSignaler.Datatype3"/>
			</t>
			<c path="hsl.haxe.HugeSignaler">
				<c path="hsl.haxe.HugeSignaler.Datatype1"/>
				<c path="hsl.haxe.HugeSignaler.Datatype2"/>
				<c path="hsl.haxe.HugeSignaler.Datatype3"/>
			</c>
		</implements>
		<dispatch public="1" set="method">
			<f a="?data1:?data2:?data3:?origin:?positionInformation">
				<c path="hsl.haxe.HugeSignaler.Datatype1"/>
				<c path="hsl.haxe.HugeSignaler.Datatype2"/>
				<c path="hsl.haxe.HugeSignaler.Datatype3"/>
				<t path="hsl.haxe.Subject"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * Dispatches a signal, containing the passed data. All the listeners that are listening to this signaler will be notified.
	 * The signal will bubble to all of the bubbling targets that were added to this signaler. This method may only be called
	 * by the subject of the signaler.
	 </haxe_doc>
		</dispatch>
		<haxe_doc>
 * A signaler that dispatches signals with three data objects inside. See GenericSignaler for more information on signalers.
 </haxe_doc>
	</class>
	<class path="Array" params="T" file="/usr/lib/haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The length of the Array
	</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Returns a new Array by appending [a] to [this].
	</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of an array with [sep] for separating each element.
	</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the last element of the array and returns it.
	</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the end of the array.
	</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Reverse the order of elements of the Array.
	</haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the first element and returns it.
	</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.
	</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].
	]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Removes [len] elements starting from [pos] an returns them.
	</haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the Array content.
	</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the start of the array.
	</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.
	</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.
	</haxe_doc>
		</remove>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>
		Returns a copy of the Array. The values are not
		copied, only the Array structure.
	</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><t path="Null"><c path="Array.T"/></t></t></f>
			<haxe_doc>
		Returns an iterator of the Array values.
	</haxe_doc>
		</iterator>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new Array.
	</haxe_doc>
		</new>
		<haxe_doc>
	An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.
</haxe_doc>
	</class>
</haxe>